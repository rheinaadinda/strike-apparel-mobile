Tugas 9

Kita perlu membuat model Dart saat mengambil atau mengirim data JSON karena model memberikan struktur yang jelas dan aman terhadap tipe data. Dengan model, setiap field memiliki tipe yang pasti (contohnya String, int, atau bool) sehingga IDE dapat melakukan pengecekan tipe dan membantu mencegah error saat proses parsing atau penggunaan data. Model juga memudahkan konversi dari dan ke JSON melalui fromJson() dan toJson() sehingga proses pengolahan data menjadi lebih konsisten dan terstandarisasi. Jika kita langsung menggunakan Map<String, dynamic> tanpa model, maka kita kehilangan perlindungan tipe dan null-safety, seperti field yang salah nama, nilai yang null, atau tipe yang tidak sesuai baru akan terdeteksi saat runtime dan menyebabkan crash yang sulit dilacak. Selain itu, kode menjadi jauh lebih sulit dirawat dan diperluas karena tidak ada struktur yang mendokumentasikan bentuk data sebenarnya. Pendekatan tanpa model membuat kode berantakan dan penuh potensi bug, sementara model memberikan maintainability, keterbacaan, dan keamanan tipe yang jauh lebih baik.

Package http berfungsi sebagai alat dasar untuk melakukan request HTTP biasa, seperti GET atau POST, tanpa mekanisme manajemen sesi. Artinya setiap request dianggap berdiri sendiri sehingga jika backend membutuhkan autentikasi atau login berbasis cookie, package http tidak otomatis mengirim atau menyimpan cookie tersebut. Kamu harus mengelola header, cookie, dan autentikasi secara manual. Sementara itu, CookieRequest (dari package pbp_django_auth) dirancang khusus untuk berkomunikasi dengan backend Django yang menggunakan session-based authentication. CookieRequest secara otomatis menyimpan cookie login, mengirimkannya kembali pada setiap request berikutnya, serta menyediakan fungsi login, logout, dan request POST/GET yang sudah terautentikasi. Dengan demikian, http cocok untuk request umum tanpa autentikasi, sedangkan CookieRequest sangat penting untuk tugas ini karena memungkinkan Flutter tetap “logged in” dan mengakses endpoint Django yang membutuhkan user session.

Instance CookieRequest perlu dibagikan ke semua komponen aplikasi Flutter karena objek inilah yang menyimpan seluruh informasi sesi user, termasuk status login dan cookie autentikasi dari Django. Jika setiap halaman atau widget membuat instance CookieRequest sendiri, maka cookie tidak akan terbagi sehingga halaman lain tidak akan mengenali bahwa user sudah login dan request ke backend yang membutuhkan autentikasi akan gagal. Dengan membagikan satu instance CookieRequest secara global melalui provider, seluruh bagian aplikasi dapat berbagi status login yang konsisten, mengakses endpoint terproteksi, serta menjaga pengalaman user tetap mulus tanpa perlu login berulang-ulang.

Agar Flutter dapat berkomunikasi dengan Django, backend dan frontend harus “saling mengizinkan” secara jaringan dan keamanan. Penambahan 10.0.2.2 pada ALLOWED_HOSTS diperlukan karena di Android emulator, localhost komputer kita direferensikan sebagai 10.0.2.2 sehingga Django hanya mau merespons request dari alamat itu jika sudah terdaftar. CORS perlu diaktifkan supaya Django mengizinkan request dari aplikasi lain (termasuk Flutter) dan tidak memblokirnya sebagai cross-origin yang berbahaya. Pengaturan SameSite/cookie penting agar cookie sesi bisa tetap terkirim pada request dari Flutter sehingga autentikasi berbasis session bekerja. Di sisi Android, izin akses internet wajib ada di AndroidManifest.xml, kalau tidak, aplikasi tidak bisa melakukan HTTP request sama sekali. Jika konfigurasi-konfigurasi ini salah atau tidak lengkap, efeknya bisa berupa request gagal, respons diblokir CORS, cookie sesi tidak terkirim (jadi selalu dianggap belum login), dan pada akhirnya Flutter tidak dapat berkomunikasi dengan Django dengan benar.

Mekanisme pengiriman data dari input sampai akhirnya tampil di Flutter berlangsung melalui beberapa tahap yang saling terhubung. Ketika user memasukkan data melalui form di Flutter, data tersebut dikumpulkan lalu dikirim ke backend Django melalui request HTTP (POST) menggunakan CookieRequest sehingga cookie sesi tetap disertakan. Django menerima data tersebut, memvalidasi, lalu menyimpannya ke database melalui model yang sudah dibuat. Setelah berhasil disimpan, Flutter kemudian melakukan request GET ke endpoint JSON Django untuk mengambil data terbaru. Django merespons dengan mengirim JSON yang berisi daftar objek yang telah disimpan di database. JSON ini lalu diparsing oleh Flutter ke dalam model Dart (misalnya ProductEntry) sehingga setiap field memiliki tipe data yang jelas. Terakhir, data model tersebut ditampilkan di UI melalui widget seperti ListView atau Card sehingga user dapat melihat data yang mereka masukkan sebelumnya.

Mekanisme autentikasi dimulai ketika user melakukan register di Flutter, yaitu data akun (username dan password) dikirim ke endpoint Django yang menangani login, lalu Django memvalidasi dan membuat user baru di database. Setelah akun ada, saat login, Flutter mengirimkan username dan password ke endpoint login Django menggunakan CookieRequest. Jika kredensial valid, Django membuat session untuk user tersebut dan mengirim kembali cookie sesi lewat respons, yang kemudian disimpan otomatis oleh CookieRequest. Cookie ini akan disertakan pada setiap request berikutnya sehingga Django bisa mengenali user sebagai “sudah login” dan mengizinkan akses ke endpoint yang diproteksi (misalnya endpoint JSON produk milik user). Setelah login sukses, Flutter biasanya meng-update state (misalnya berpindah dari halaman login ke halaman menu/home) dan menampilkan konten yang hanya bisa diakses user terautentikasi. Saat logout, Flutter memanggil endpoint logout Django. Django menghapus session di server dan mengembalikan respons, sementara CookieRequest menghapus cookie lokal sehingga request berikutnya tidak lagi dianggap login dan Flutter bisa mengarahkan user kembali ke halaman login.

Pertama saya pastikan dulu proyek Django-nya sehat dan bisa diakses.saya cek settings.py: nambah 10.0.2.2 ke ALLOWED_HOSTS, aktifin django-cors-headers, set CORS_ALLOW_ALL_ORIGINS, CORS_ALLOW_CREDENTIALS, dan atur SESSION_COOKIE_SAMESITE / CSRF_COOKIE_SAMESITE ke 'None' sesuai kebutuhan integrasi Flutter. Di sisi Django,saya pastikan flow login–register sudah jalan dulu untuk web. Lalu saya tambahin endpoint khusus yang bisa dikonsumsi Flutter (format JSON), misalnya untuk login dan register, dengan mengembalikan JsonResponse berisi informasi user. Fungsi-fungsi ini saya lengkapi dengan authenticate dan login supaya kalau kredensial benar, Django bikin session dan ngasih cookie ke client. Nantinya cookie ini yang akan dipegang CookieRequest di Flutter. Di Flutter,saya bikin dua halaman baru, yaitu LoginPage dan RegisterPage. Masing-masing pakai TextEditingController buat ambil input username dan password dari user. Untuk register,saya kirim body JSON (username dan password) ke endpoint /auth/register/ Django pakai request.postJson, terus kalau statusnya sukses saya balikkan user ke halaman login. Untuk login, saya pakai request.login("http://localhost:8000/auth/login/". Kalau request.loggedIn == true, berarti Django sudah ngasih cookie session dan CookieRequest otomatis nyimpan. Setelah itu saya Navigator.pushReplacement ke MyHomePage dan tampilin snackbar “Login berhasil”. Supaya semua halaman bisa pakai sesi login yang sama, saya ubah main.dart dan bungkus MaterialApp pakai Provider yang nge-provide satu instance CookieRequest. Di setiap screen yang butuh komunikasi ke backend. Dengan cara ini, halaman menu, list produk, form Flutter, semuanya pakai session yang sama tanpa harus login ulang. Setelah backend siap, saya buka endpoint /json/ Django, ambil contoh JSON-nya, lalu generate model Dart pakai Quicktype dan saya sesuaikan lagi. Jadinya class ProductEntry dengan field seperti id, name, description, category, thumbnail, productViews, price, stock, rating, brand, createdAt, isFeatured, dan userId. Di dalamnya ada factory ProductEntry.fromJson dan toJson() supaya konversi JSON ke objek rapi dan aman secara tipe. Model ini yang kupakai di semua halaman Flutter saat parsing respons Django. Lalu, saya bikin screen ProductEntryListPage. Di situ saya tulis fungsi fetchProduct(CookieRequest request) yang manggil request.get('http://localhost:8000/json/') lalu looping responsnya dan tiap elemen ku-convert jadi ProductEntry. Di build, saya pakai FutureBuilder dan kalau datanya sudah ada, saya tampilkan pakai ListView.builder dengan ProductEntryCard. Di dalam card itu saya nampilin field yang diminta, yaitu name, price, description, thumbnail (lewat endpoint proxy-image), category, dan badge Featured. Lalu, saya bikin ProductDetailPage yang menerima satu argumen ProductEntry product. Dari ProductEntryListPage, waktu user klik card, saya pakai Navigator.push ke ProductDetailPage. Di halaman detail ini saya tampilkan semua atribut model, seperti id, name, description lengkap, category, thumbnail, price, stock, rating, brand, views, tanggal, dll. Di bagian bawah saya tambahin satu ElevatedButton “Back to List” yang isinya Navigator.pop supaya memenuhi requirement. Karena tugasnya juga minta filter produk berdasarkan user login, saya tambah view baru show_json_my_products di main/views.py. Isinya Product.objects.filter(user=request.user) lalu dikonversi ke list dictionary dengan struktur sama seperti /json/ (ada id, name, description, category, thumbnail, product_views, price, stock, rating, brand, created_at, is_featured, user_id). View ini saya kasi decorator @login_required dan didaftarkan di urls.py sebagai path json/my-products/, posisinya saya taruh sebelum route json/str:product_id/ supaya nggak ketangkep sebagai param id.

Tugas 8

Jelaskan perbedaan antara Navigator.push() dan Navigator.pushReplacement() pada Flutter. Dalam kasus apa sebaiknya masing-masing digunakan pada aplikasi Football Shop kamu?
Navigator.push() --> Menambahkan halaman baru di atas stack navigasi tanpa menghapus halaman sebelumnya. Di aplikasi Football Shop, fungsi ini cocok untuk navigasi yang tidak menggantikan halaman utama, misalnya saat pengguna menekan tombol “Detail Produk” dari halaman katalog. Jadi, ketika pengguna klik tombol back, ia bisa balik.

Navigator.pushReplacement() --> Mengganti halaman saat ini dengan halaman baru sehingga halaman sebelumnya dihapus dari stack. Di aplikasi Football Shop, fungsi ini cocok untuk navigasi setelah proses login atau checkout sukses, di mana pengguna tidak perlu kembali ke halaman sebelumnya. Jadi, pengguna tidak bisa kembali ke halaman sebelumnya dengan tombol back.

Bagaimana kamu memanfaatkan hierarchy widget seperti Scaffold, AppBar, dan Drawer untuk membangun struktur halaman yang konsisten di seluruh aplikasi?
Scaffold --> Memberikan struktur dasar halaman seperti body, AppBar, Drawer, dan FloatingActionButton. Di Football Shop, ini membantu menjaga tampilan halaman tetap seragam.

AppBar --> Berfungsi sebagai header halaman, menampilkan judul, ikon pencarian, atau keranjang belanja.

Drawer --> Menyediakan navigasi global antarhalaman seperti Home, Kategori, dan Profil. Dengan ini, pengguna bisa berpindah antarhalaman dengan mudah tanpa mengubah struktur utama.

Dalam konteks desain antarmuka, apa kelebihan menggunakan layout widget seperti Padding, SingleChildScrollView, dan ListView saat menampilkan elemen-elemen form? Berikan contoh penggunaannya dari aplikasi kamu.
Padding --> Menambah jarak antar elemen agar tampilan lebih rapi dan mudah dibaca.

SingleChildScrollView --> Membuat halaman bisa di-scroll ketika konten lebih panjang dari layar, terutama untuk form checkout atau registrasi.

ListView --> Digunakan untuk menampilkan daftar item seperti list produk, keranjang belanja, atau riwayat pesanan.

Bagaimana kamu menyesuaikan warna tema agar aplikasi Football Shop memiliki identitas visual yang konsisten dengan brand toko?
Saya memanfaatkan ThemeData di MaterialApp untuk menentukan warna utama, sekunder, dan gaya teks agar mencerminkan identitas brand Football Shop saya. Dengan begitu, seluruh komponen (AppBar, tombol, ikon, teks) mengikuti identitas visual yang konsisten dengan citra Football Shop saya.


Tugas 7
1. Jelaskan apa itu widget tree pada Flutter dan bagaimana hubungan parent-child (induk-anak) bekerja antar widget.
Widget tree dalam Flutter adalah struktur hierarki yang menggambarkan bagaimana seluruh widget tersusun di dalam aplikasi. Setiap elemen tampilan, seperti teks, gambar, tombol, dan layout, merupakan widget yang saling terhubung melalui hubungan parent-child (induk-anak). Widget induk bertanggung jawab mengatur tata letak dan perilaku widget anak, seperti posisi, ukuran, dan urutan tampilannya. Misalnya, sebuah Column dapat menjadi parent yang berisi beberapa child seperti Text dan ElevatedButton, yang disusun secara vertikal. Dengan cara ini, Flutter membangun antarmuka pengguna melalui kombinasi widget yang saling bersarang.

2. Sebutkan semua widget yang kamu gunakan dalam proyek ini dan jelaskan fungsinya.
Dalam proyek ini, terdapat beberapa widget yang digunakan dengan fungsinya masing-masing. Widget MaterialApp berperan sebagai kerangka utama aplikasi berbasis Material Design, sedangkan Scaffold menyediakan struktur halaman seperti AppBar dan body. Widget AppBar digunakan untuk menampilkan bagian atas halaman dengan judul aplikasi. Kemudian, Column dan Row digunakan untuk menyusun elemen secara vertikal dan horizontal. Container berfungsi sebagai pembungkus fleksibel yang dapat diatur ukuran, warna, dan jaraknya. Widget lain seperti Text digunakan untuk menampilkan teks, Image untuk menampilkan gambar, ElevatedButton untuk membuat tombol interaktif, dan Icon untuk menampilkan ikon. Semua widget tersebut bekerja sama membentuk tampilan antarmuka yang terstruktur dan interaktif.

3. Apa fungsi dari widget MaterialApp? Jelaskan mengapa widget ini sering digunakan sebagai widget root.
Widget MaterialApp memiliki fungsi utama sebagai pembungkus seluruh aplikasi yang menggunakan gaya Material Design. Widget ini mengatur elemen penting seperti judul aplikasi, tema (warna, font, dan gaya), serta navigasi antar halaman. MaterialApp sering digunakan sebagai widget root karena menyediakan konteks global yang memungkinkan widget lain seperti Scaffold, AppBar, dan FloatingActionButton berfungsi dengan benar. Dengan menjadikannya widget root, aplikasi Flutter dapat menggunakan sistem desain Material secara konsisten di seluruh halaman.

4. Jelaskan perbedaan antara StatelessWidget dan StatefulWidget. Kapan kamu memilih salah satunya?
Perbedaan utama antara StatelessWidget dan StatefulWidget terletak pada kemampuan mereka dalam menampung dan mengelola data yang berubah. StatelessWidget bersifat statis, artinya tampilannya tidak berubah selama aplikasi berjalan; cocok digunakan untuk elemen yang tidak membutuhkan pembaruan, seperti teks atau ikon. Sebaliknya, StatefulWidget memiliki state yang dapat berubah dan dapat memperbarui tampilannya menggunakan metode setState(). Widget jenis ini digunakan ketika ada interaksi pengguna atau data yang dinamis, seperti tombol counter, input form, atau tampilan yang bergantung pada data API. Dengan demikian, pemilihan di antara keduanya tergantung pada kebutuhan perubahan data dalam tampilan aplikasi.

5. Apa itu BuildContext dan mengapa penting di Flutter? Bagaimana penggunaannya di metode build?
BuildContext adalah objek yang merepresentasikan posisi suatu widget di dalam widget tree. Objek ini penting karena memungkinkan widget untuk berinteraksi dengan widget lain di atasnya (ancestor), misalnya untuk mengambil tema menggunakan Theme.of(context) atau melakukan navigasi melalui Navigator.of(context). Dalam metode build(), BuildContext digunakan untuk menentukan bagaimana tampilan widget dibangun berdasarkan lingkungan atau posisi widget tersebut dalam hierarki aplikasi. Dengan kata lain, BuildContext menjadi penghubung antara widget dengan struktur keseluruhan aplikasi Flutter.

6. Jelaskan konsep "hot reload" di Flutter dan bagaimana bedanya dengan "hot restart".
Konsep Hot Reload dalam Flutter memungkinkan pengembang untuk melihat perubahan kode secara langsung tanpa harus menghentikan aplikasi, dan tanpa kehilangan state atau data yang sedang berjalan. Fitur ini sangat berguna ketika melakukan penyesuaian pada tampilan UI atau logika kecil secara cepat. Sementara itu, Hot Restart akan memulai ulang seluruh aplikasi dari awal dan menghapus semua state yang tersimpan, seolah-olah aplikasi baru dijalankan kembali. Perbedaan utamanya adalah Hot Reload mempertahankan kondisi aplikasi, sedangkan Hot Restart mengembalikan aplikasi ke keadaan awal.